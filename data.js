'number' + 3 + 3; //number33;
/* если сначала идет строка, 
то весь пример конкатенируется в строку*/;

null + 3;  //3 ;
//"null" конкатенируется в "0" при сложении с цифрами;

5 && "qwerty"; //qwerty;
/*код слева направо выполняется, 
проверяет первое условие (истина) и движется дальше, 
если второе тоже тру, то он его выводит*/;

+'40' + +'2' + "hillel"; //42hillel;
/*знак "+" конкатенирует строку c числом в валидное число.
Получается 40+2+"hillel"*/;

'10' - 5 === 6; //false
/*при вычетании числа из строки чисельного вида, 
строка преобразуется в число. Выходит 5===6. 5 не равняется 6, потому false*/

true + false;//1
/*при выполнении арифметических операций, 
логические операторы преобразуются в числовые "эквиваленьы" - 1 и 0 соответвенно. 
1+0 = 1;*/

'4px' - 3 //Nan
/*строка "4px" будет преобразована в число для вычетания из него трех,
но числа "4px" не существует,
потому "not a number"
*/

'4' - 3; //1
/* строка переходит в число, 4-3 =1 */

'6' + 3 ** 0; //61
/*по приоритетности сначал выполняется возведение в степень,
любое число в 0 степени = 1.
Потом конкатенация в строку - строка "6" плюс строка "1" равно "61" */

12 / '6'; //2
/* если сначала стоит число, 
то и строка после него будет конвертирована в число. 12/6=2; */

'10' + (5 === 6); //10false
/*сначал проверяется часть в скобках, 5 не равно 6 потому результат -false.
Потому берется строка "10" с оператором "+" все выражение конкатенируется в строку.
Выходит "10" + "false" = 10false. */

null == ''; //false
/*если один из операторов null либо undefined, то и преравниваемый к ним 
оператор должен быть null либо undefined, иначе - false. */

3 ** (9 / 3); //27
/*сначала выполняется часть в скобаках, 9 разделить на 3, будет 3.
Потом 3 подносится к третье степени- 3 * 3 * 3 = 27*/

!!'false' == !!'true'; //true
/*не пустая строка всегда будет равна true/1 в преобразовании на булевое (!!), 
следственно true/1 = true/1 */

0 || '0' && 1; //1
/*сначала сравнивается правая часть, ибо "&&" имеет выше приоритет. 
Левое значение приводится к bool и если оно false, то возвращается само значение "0".
Теперь сравниваются 0 либо "0", если есть хотя бы один true, то должно выводиться true.
"0" не пустая строка, потому будет true.
*/
(+null == false) < 1; //false
/* унарный оператор "+" преобразует "null" в число - 0. 
0 и false приводятся к числовому типу, потому 0 = 0 - true.
True<1 преобразуются к числовому типу - 1<1 -false */

false && true || true // true
/*(для &&)если хотя бы один операнд false - результатом будет false.
Теперь проверяем false либо true, если хотя бы один является истиной, то результатом будет истина.
*/


false && (false || true); //false
/* выражение в скобках имеет наивысший приоритет, потому false || true, будет true.
Теперь переходим к первой части- если хотя бы один операнд false, результатом будет false.
False && true - false.
*/

(+null == false) < 1 ** 5; // false
/* Начинаем со скобок, преобразуем null в число, ибо опертор "+". 0==0 - true.
Переходим к поднесенью к степени, по приоритетности, - 1 в любой степени будет 1 (кроме дробных, полагаю).
True<1 преобразуем в числа. 1<1 - false.